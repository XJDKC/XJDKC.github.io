<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nodepad++结合DOSBox配置一键编译运行]]></title>
    <url>%2FNodepad%2B%2B%E7%BB%93%E5%90%88DOSBox%E9%85%8D%E7%BD%AE%E4%B8%80%E9%94%AE%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C.html</url>
    <content type="text"><![CDATA[前言 最近在学习汇编语言程序设计，在最开始肯定是要配置环境啦，但是我们学的还只是8086系列的处理器的汇编，而现在的CPU是酷睿系列了，根本不支持，所以就需要用到DOSBox来模拟环境，然而这就遇到一个问题了：DOSBox编译链接运行程序十分麻烦，而且每次重新打开都需要输入一大堆东西，很是浪费时间，那么如何简单快捷的实现像写C,C++时那样一个快捷键源代码就自动编译运行了呢？于是就有了这篇博文。 配置环境 首先介绍一下实现环境： DOSBox 0.74 模拟DOS系统 Notepad++ v7.5.6 (64 bit) 用于编辑汇编源程序 MASM 5.0 汇编程序编译器 LINK 连接程序 * TD Turbor Debugger 调试器 这些软件需要自己下好并安装在对应位置，其中MASM LINK TD需要英文路径。 具体实现 实现的大致思路就是通过Notepad++运用批处理指令打开DOSBox 并在其中输入相关指令使源代码编译链接运行，实现编译运行调试的快捷指令需要三步 修改DOSBox配置文件首先打开以下路径： C:\Users\Mr. Xing\AppData\Local\DOSBox 然后就会在其中看到DOSBox的配置文件 dosbox-0.74.conf 用记事本打开在最下方的autoexec下输入MASM,LINK,TD的存放目录即 mount c d:\program\asmc: 然后在保存关闭,这样在运行DOSBox的时候就会首先执行这两行而不用重新输入。两行指令意思是 将d:\program\asm挂载为DOSBox下的c盘 进入c盘 配置编译运行修改完DOSBox的配置文件，接下来就需要配置编译运行快捷键了。首先打开Notepad++ 输入一段测试汇编源程序，例如：12345678910111213141516171819202122.386;----------------------------STACK SEGMENT STACK use16 DB 200 DUP(0)STACK ENDS;----------------------------DATA SEGMENT use16MSG DB &apos;How are you! $&apos;DATA ENDS;------------------------------CODE SEGMENT use16 ASSUME CS:CODE,DS:DATA,SS:STACKBEGIN: MOV AX, DATA MOV DS, AX MOV DX, OFFSET MSG MOV AH, 9 INT 21H MOV AH,4CH ;exit INT 21H;-----------------------------CODE ENDS END BEGIN 然后点击菜单项的运行，如下图: 然后输入以下命令 D:\软件\DOSBox\DOSBox-0.74\DOSBOX.exe -c &quot;@echo off&quot; -c &quot;mount d $(CURRENT_DIRECTORY)&quot; -c &quot;MASM d:\$(NAME_PART).asm;&quot; -c &quot;LINK $(NAME_PART).obj;&quot; -c &quot;COPY $(NAME_PART).exe d:\$(NAME_PART).exe&quot; -c cls -c &quot;d:\$(NAME_PART).exe&quot; -c echo. -c pause -c exit 这段指令的意思如下: D:\软件\DOSBox\DOSBox-0.74\DOSBOX.exe DOSBox 软件运行程序文件地址 -c DOSBox command 命令 后跟一条指令且每条指令之前都要加-c @echo off 批处理指令 意思是关闭回显(这样在输入每条指令的时候就不会有c:\之类的) mount d $(CURRENT_DIRECTORY) 将当前汇编源程序挂在到DOSBox的d盘 MASM d:\$(NAME_PART).asm; 编译asm源程序生成二进制目标文件 LINK $(NAME_PART).obj; 链接二进制目标文件生成EXE文件 COPY $(NAME_PART).exe d:\$(NAME_PART).exe 将生成的EXE文件复制到源代码目录下 cls 清屏 d:\$(NAME_PART).exe 运行生成程序 echo. 换行 pause 暂停 exit 退出DOSBox $(FULL_CURRENT_PATH) 当前文件绝对路径 如d:\program\asm\demo.asm $(CURRENT_DIRECTORY) 当前目录 如d:\program\asm $(NAME_PART) 当前文件文件名 如demo $(FILE_NAME) 当前文件全名 如demo.asm $(EXT_PART) 当前文件扩展名如 asm 特别注意:如果你的源代码在E盘,那么请在输入指令的时候将源代码挂载到E盘这段程序只适合于保存到D:盘任何地方的asm文件 然后保存设置响应的名称和快捷键就OK了(我设置的是CTRL+ALT+B)，具体运行效果如下: 配置调试同理只需要在运行框中输入以下批处理指令即可 D:\软件\DOSBox\DOSBox-0.74\DOSBOX.exe -c &quot;mount d $(CURRENT_DIRECTORY)&quot; -c &quot;TD d:\$(NAME_PART).exe&quot; 运行结果如下: 写在最后这次实现一键编译翻了许多文档，发现最全的还是官方文档，学习到了许多关于批处理的知识，收获还是蛮多的。还有就是由于指令长度的限制 在一键编译的时候并没有删除编译得到的obj和exe文件需要清理，有需要的小伙伴可以怎加一条指令del专门清理.obj 和 .exe如果有什么疑惑或者见解欢迎留言。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>汇编assembly</tag>
        <tag>DOSBox</tag>
        <tag>Notepad++</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒子与小球]]></title>
    <url>%2F%E5%B0%8F%E7%90%83%E4%B8%8E%E7%9B%92%E5%AD%90.html</url>
    <content type="text"><![CDATA[Description of the Problem: 你有K个相同的盒子，N个互不相同的物品。你准备把这N个物品装入K个盒子，每个盒子最少要放入一个物品。问一共会有多少种分配方法。由于方案数很大，只需要输出方案总数除以10000的余数。 INPUT： 第一行有一个正整数 t ，表示数据组数(不多于50)。每组数据仅一行，两个整数， N 和K，其中1≤N ≤ 10^9，K≤min(50,N)。 OUTPUT： 每行输出一个整数，为方案总数除以10000的余数。 Analysis: 这是一个来自于同为HUSTer的高中童鞋的问题,从这个问题描述中,我们可以知道把N个物品放入K个相同的盒子的方法数就是 把N-1个物品放入K-1个盒子的方法数 加上 把N-1个物品放入K个盒子的方法数*K,为什么?我们只要考虑最后一个盒子和最后一个球即可,由于盒子是相同的,那么有两种情况 1.最后一个盒子只有一个球且为第N个球，即前面N-1个球没有填满K个盒子，最后一个球只能放在空盒子里。这种情况方法数就等于把N-1个物品放入K-1个盒子的方法数。 2.前面N-1个球填满的K个盒子，那么最后一个球可以任意放。这种情况方法数就等于 把N-1个物品放入K个盒子的方法数*K。 所以如果用f(N,K)来表示 N个物品K个盒子的方法数，可以得到以下递推式 f(N,K)=f(N-1,K-1)+f(N-1,K)*K;(即第二类斯特林数) 所以现在已经可以用程序通过递推算出结果（递归也可以但要慢一些，即使是记忆化递归）。但问题解决了吗？ 答案是：NO。由于N很大所以要一项一项递推计算f(N,K)肯定会超时应为至少要算N*K次，所以显然要找更快速的算法让时间复杂度降低O(logn*K)。我们这时可以运用矩阵+快速幂的形式来解决这个问题。 首先来解释一下什么是快速幂：举个例子，对于计算q^k，我们其实可以将之看成q^[a(n)*2^n+a(n-1)*2^(n-1)+……a(1)*2^1+a(0)*2^0],其中a(n)=0或1。即把k看成许多{2^m}中某n+1项之和，那么怎么快速计算q^k呢？我们先把q^k看成n+1项之积，然后我们可以对k不断除2取余，如果第i次除2后余数为1，那么表示a(i-1)=1，即有n+1项乘积中有q^(i-1)这一项，具体描述步骤如下 首先我们用让一个数ans=1，用来存答案，用一个数x来存q^(i-1)，x开始为1，然后先对k进行第一次除以2，如果余数为1，证明a(0)=1，有q^0这一项，于是让ans*=x,如果不为1，证明不存在这一项(或者说着这一项为1)，就不用乘，然后进行完上述操作，x*=q; 然后我们对k进行第二次除以2，此时x=q^1，如果余数为1，证明a(1)=1，有q^1这一项，于是让ans*=x,如果不为1，证明不存在这一项(或者说着这一项为1)，就不用乘，然后进行完上述操作，x*=q;所以在对k进行第i次除以2操作时，x=q^(i-1)， 如果余数为1，证明a(i-1)=1，有q^(i-1)这一项，于是让ans*=x,如果不为1，证明不存在这一项(或者说着这一项为1)，就不用乘，然后进行完上述操作，x*=q;最后如果k=0证明已经除完了，ans已经算完那么就得到了结果，结束运算。 现在来分析一下算法效率，若按照原算法计算q^k要乘k次也就是计算k次，用现在的快速幂算法，则要除以[log2(k)]+1次，也就是x要乘[log2(k)]+1次，而如果a(n)均为1，那么要ans也要乘 [log2(k)]+1，所以最多算2{[log2(k)]+1}次算法效率为O(logk)。 现在来讲一讲矩阵乘法： 定义：设A为m×p的矩阵，B为p×n的矩阵，那么称m×n的矩阵C为矩阵A与B的乘积，记作C=A×B 计算方法：乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。 性质：乘法结合律：(AB)C=A(BC) 所以我们可以把原问题的递推式子变成一个矩阵递推式$$\begin{equation}\begin{pmatrix}f(n,k)\\f(n,k-1)\\\vdots\\f(n,2)\\f(n,1)\\\end{pmatrix}={\begin{pmatrix}k&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;k-1&amp;1&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;2&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\\end{pmatrix}}{\begin{pmatrix}f(n-1,k)\\f(n-1,k-1)\\\vdots\\f(n-1,2)\\f(n-1,1)\\\end{pmatrix}}\end{equation}$$ 所以可以用矩阵递推式把原递推式变成等比数列形式那么可以得到以下式子$$\begin{equation}\begin{pmatrix}f(n,k)\\f(n,k-1)\\\vdots\\f(n,2)\\f(n,1)\\\end{pmatrix}={\begin{pmatrix}k&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;k-1&amp;1&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;2&amp;1\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\\end{pmatrix}}^{(n-k)}{\begin{pmatrix}f(k,k)\\f(k,k-1)\\\vdots\\f(k,2)\\f(k,1)\\\end{pmatrix}}\end{equation}$$ 然后我们将快速幂与矩阵乘法递推式结合起来，我们只需要先用递推计算出base矩阵，然后用快速幂算出per矩阵的(n-k)次方两者相乘得到ans 其中我们将ans矩阵不再初始化为1，而是初始化为矩阵中的“1”(其他矩阵相乘等于其他)。$${\begin{pmatrix}1&amp;0&amp;0&amp;\cdots&amp;0&amp;0\\0&amp;1&amp;0&amp;\cdots&amp;0&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;\cdots&amp;1&amp;0\\0&amp;0&amp;0&amp;\cdots&amp;0&amp;1\\\end{pmatrix}}$$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int mod=10000;struct matrix&#123; long long m[66][66];&#125;;matrix per,ans,base,cal,unit; matrix mul(matrix a,matrix b,int x,int y,int z)&#123; matrix c; for (int i=0;i&lt;x;i++) for (int j=0;j&lt;z;j++) &#123; c.m[i][j]=0; for (int k=0;k&lt;y;k++) c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j])%mod; c.m[i][j]=c.m[i][j]%mod; &#125; return c;&#125;matrix qpow(int n,int k)&#123; matrix p=per; int ci=n-k; while (ci) &#123; if (ci&amp;1) &#123; unit=mul(unit,p,k,k,k); ci--; &#125; else &#123; p=mul(p,p,k,k,k); ci&gt;&gt;=1; &#125; &#125; return unit;&#125;void init(int k)&#123; for (int i=0;i&lt;50;i++) for (int j=0;j&lt;50;j++) &#123; if (i==j&amp;&amp;i&lt;k) per.m[i][j]=k-i; else if (j-1==i&amp;&amp;j&lt;k) per.m[i][j]=1; else per.m[i][j]=0; if(i==j) unit.m[i][j]=1; else unit.m[i][j]=0; &#125; for (int i=0;i&lt;k;i++) base.m[i][0]=cal.m[k-1][k-1-i];&#125;void calculation()&#123; for (int i=0;i&lt;50;i++) cal.m[i][i]=cal.m[i][0]=1; for(int i=1;i&lt;50;i++) for(int j=1;j&lt;i;j++) cal.m[i][j]=(cal.m[i-1][j]*(j+1)+cal.m[i-1][j-1])%mod;&#125;int main()&#123; int t,n,k; cin&gt;&gt;t; calculation(); while (t--) &#123; cin&gt;&gt;n&gt;&gt;k; init(k); matrix xi=qpow(n,k); ans=mul(xi,base,k,k,1); cout&lt;&lt;ans.m[0][0]&lt;&lt;endl; &#125; return 0;&#125; Addition：下面给出一部分结果 n k 1 2 3 4 5 6 7 8 1 1 2 1 1 3 1 3 1 4 1 7 6 1 5 1 15 25 10 1 6 1 31 90 65 15 1 7 1 63 301 350 140 21 1 8 1 127 966 1701 1050 266 28 1]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
